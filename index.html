<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <title>Block Playground 🧱</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Fredoka', 'Segoe UI', Roboto, -apple-system, BlinkMacSystemFont, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background-color: #fff8e6;
            background-image: radial-gradient(#ffe3a3 1.5px, transparent 1.5px), radial-gradient(#ffd1dc 1.5px, transparent 1.5px);
            background-position: 0 0, 15px 15px;
            background-size: 30px 30px;
            padding: 8px;
            touch-action: none;
            overflow-x: hidden;
            min-height: 100vh;
            position: relative;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 8px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 12px;
            font-size: clamp(24px, 6vw, 32px);
            letter-spacing: 0.5px;
            padding: 0 10px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .value-selector {
            display: flex;
            align-items: center;
            gap: 5px;
            background: white;
            padding: 8px 12px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 44px;
        }
        
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .popup-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .popup {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            width: 80%;
            text-align: center;
            transform: translateY(20px);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
        }
        
        .popup.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        .popup h3 {
            margin: 0 0 15px 0;
            color: #FF6B6B;
            font-size: 22px;
        }
        
        .popup p {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 16px;
            line-height: 1.4;
        }
        
        .popup-button {
            background-color: #1a73e8;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .popup-button:hover {
            background-color: #1557b0;
        }
        
        .value-select {
            width: 70px;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23333%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px auto;
            padding-right: 30px;
            min-height: 44px;
            touch-action: manipulation;
        }
        
        .value-select:focus {
            outline: none;
            border-color: #4285f4;
            box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
        }

        button {
            padding: 16px 20px;
            font-size: 16px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease, background-color 0.2s ease;
            min-width: 120px;
            min-height: 44px;
            font-weight: 700;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .add-button {
            background-color: #4D96FF;
            color: white;
            flex: 1;
        }

        .add-button:active {
            background-color: #2f7bf2;
            transform: translateY(1px);
            box-shadow: 0 3px 0 rgba(0,0,0,0.12);
        }

        .reset-button {
            background-color: #FF6B6B;
            color: white;
            flex: 1;
        }

        .reset-button:active {
            background-color: #ff5252;
            transform: translateY(1px);
            box-shadow: 0 3px 0 rgba(0,0,0,0.12);
        }

        .counter {
            display: flex;
            align-items: center;
            font-size: 16px;
            font-weight: bold;
            background: white;
            padding: 12px 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex: 0 0 100%;
            justify-content: center;
            margin-top: 8px;
            min-height: 44px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
            margin-top: 10px;
            position: relative;
            min-height: 70vh;
        }

        .cube-area, .combining-area {
            position: relative;
            width: 100%;
            min-height: 220px;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .cube-area {
            border: 3px solid #4D96FF;
            background-color: #eaf2ff;
            flex: 0 0 auto;
            order: 1;
        }

        .cube-area h3 {
            color: #4D96FF;
            margin: 0 0 10px 0;
            text-align: center;
        }

        .cube-area .plus-icon {
            font-size: 40px;
            color: #1a73e8;
            margin: 5px 0;
            text-align: center;
        }

        .combining-area {
            border: 3px dashed #ffb703;
            background-color: #fff3cd;
            flex: 1;
            min-height: 280px;
            transition: border-color 0.2s ease, background-color 0.2s ease;
            order: 2;
        }
        
        .combining-area.drag-over {
            border-color: #1a73e8;
            background-color: #e8f0fe;
            border-style: solid;
        }

        .cube {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 28px;
            cursor: move;
            touch-action: none;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 6px 0 rgba(0,0,0,0.08), 0 6px 10px rgba(0, 0, 0, 0.12);
            z-index: 10;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Cute face for blocks */
        .cube .num {
            position: relative;
            z-index: 2;
            font-size: calc(var(--size, 60px) * 0.45);
            line-height: 1;
        }
        .cube .face {
            position: absolute;
            top: calc(var(--size, 60px) * 0.28);
            left: 50%;
            width: calc(var(--size, 60px) * 0.6);
            height: calc(var(--size, 60px) * 0.4);
            transform: translateX(-50%);
            pointer-events: none;
        }
        .cube .eye {
            position: absolute;
            top: calc(var(--size, 60px) * 0.02);
            width: calc(var(--size, 60px) * 0.14);
            height: calc(var(--size, 60px) * 0.14);
            background: #333;
            border-radius: 50%;
        }
        .cube .eye.left { left: 22%; }
        .cube .eye.right { right: 22%; }
        .cube .smile,
        .cube .face,
        .cube .eye {
            display: none !important;
        }

        .cube.dragging {
            transform: scale(1.15);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            opacity: 0.95;
            z-index: 1000;
            transition: none;
        }

        .instructions {
            margin-top: 16px;
            padding: 16px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 15px;
        }

        .instructions h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .instructions ul {
            list-style-type: none;
            padding-left: 15px;
        }

        .instructions li {
            margin-bottom: 8px;
            position: relative;
            padding-left: 24px;
            font-size: 16px;
            line-height: 1.4;
        }

        .instructions li:before {
            content: '•';
            position: absolute;
            left: 0;
            color: #4285f4;
        }
        
        /* Combine pop animation */
        @keyframes pop {
            0% { transform: scale(0.85); }
            60% { transform: scale(1.12); }
            100% { transform: scale(1); }
        }
        .cube.pop { animation: pop 220ms ease-out; }
        
        /* Touch feedback animations */
        @keyframes touchFeedback {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }
        
        .cube.touch-feedback { animation: touchFeedback 150ms ease-out; }
        
        /* Haptic-style button press */
        button:active {
            transform: scale(0.98) translateY(1px);
        }

        /* Shake animation for feedback */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }
        
        /* Mobile-first vertical layout */
        @media (max-width: 767px) {
            .controls {
                gap: 8px;
                flex-direction: column;
                align-items: stretch;
            }
            
            .controls > * {
                width: 100%;
                justify-content: center;
            }
            
            .add-button, .reset-button {
                font-size: 16px;
                padding: 16px 20px;
                min-width: 100%;
                margin: 4px 0;
            }
            
            .value-selector {
                justify-content: center;
                margin-bottom: 8px;
            }
            
            .value-selector label {
                font-size: 16px;
            }
            
            .counter {
                margin-top: 8px;
                order: 3;
            }
            
            .cube-area {
                min-height: 200px;
                padding: 16px;
                order: 1;
            }
            
            .combining-area {
                min-height: 320px;
                padding: 16px;
                order: 2;
            }
            
            .game-container {
                gap: 16px;
                min-height: 75vh;
            }
            
            /* Optimized cube sizes for mobile */
            .cube {
                min-width: 55px;
                min-height: 55px;
            }
            
            h1 {
                font-size: clamp(26px, 7vw, 32px);
                margin-bottom: 16px;
            }
        }
        
        /* Tablet and desktop layout */
        @media (min-width: 768px) {
            .controls {
                flex-direction: row;
                flex-wrap: nowrap;
            }
            
            .controls > * {
                width: auto;
            }
            
            .counter {
                flex: 0 0 auto;
                margin-top: 0;
                padding: 8px 15px;
                order: 0;
            }
            
            h1 {
                font-size: 32px;
            }
        }
        
        /* Large desktop layout - horizontal */
        @media (min-width: 1024px) {
            .game-container {
                flex-direction: row;
                min-height: 50vh;
            }
            
            .cube-area {
                width: 220px;
                min-height: 400px;
                order: 1;
            }
            
            .combining-area {
                min-height: 400px;
                order: 2;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Block Playground 🧱</h1>
        <div class="controls">
            <div class="value-selector">
                <label for="cubeValue">Pick a number:</label>
                <select id="cubeValue" class="value-select">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                </select>
            </div>
            <button id="addCube" class="add-button">➕ Add a Block</button>
            <button id="resetGame" class="reset-button">🔄 Start Over</button>
            <div class="counter">Blocks: <span id="cubeCount">0</span></div>
        </div>
        <div class="game-container">
            <div class="cube-area" id="cubeArea">
                <h3>Block Box <span id="cubeCountDisplay">(0/6)</span></h3>
                <div class="plus-icon">+</div>
                <p>Tap "Add a Block" to begin! 🎉</p>
                <!-- Popup for warning message -->
                <div id="warningPopup" class="popup-overlay">
                    <div class="popup">
                        <h3>Oops! The Box is Full</h3>
                        <p>You have 6 blocks. Mix some together in the Mix & Match Zone to make space. 😊</p>
                        <button id="closePopup" class="popup-button">Okay!</button>
                    </div>
                </div>
            </div>
            <div id="combiningArea" class="combining-area">
                <div style="position: absolute; top: 10px; left: 10px; color: #5f6368; font-size: 16px; font-weight: bold; color: #1a73e8;">
                    Mix & Match Zone
                </div>
                <div style="position: absolute; top: 40px; left: 10px; color: #5f6368; font-size: 14px;">
                    Drag blocks here to make bigger numbers!
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li>Tap "Add a Block" to make a new block</li>
                <li>Drag blocks to the Mix & Match Zone</li>
                <li>Drop one block on another to add them together</li>
                <li>Make the biggest number you can! ⭐</li>
            </ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const cubeArea = document.getElementById('cubeArea');
            const combiningArea = document.getElementById('combiningArea');
            const addButton = document.getElementById('addCube');
            const resetButton = document.getElementById('resetGame');
            const cubeCountElement = document.getElementById('cubeCount');
            const cubeCountDisplay = document.getElementById('cubeCountDisplay');
            const warningPopup = document.getElementById('warningPopup');
            const closePopup = document.getElementById('closePopup');
            const cubeValueSelect = document.getElementById('cubeValue');
            
            let cubeCount = 0;
            let activeCube = null;
            let offsetX = 0, offsetY = 0;
            let highestValue = 0;
            let isTouchDevice = 'ontouchstart' in window;

            // Initialize the game
            function init() {
                // Add event listeners
                addButton.addEventListener('click', addNewCube);
                resetButton.addEventListener('click', resetGame);
                closePopup.addEventListener('click', closeWarningPopup);
                
                // Add initial cube
                addNewCube();

                // Cleanup any existing face/eye/smile elements from older blocks
                document.querySelectorAll('.smile, .eye, .face').forEach(el => el.remove());
            }

            // Show warning popup
            function showWarningPopup() {
                warningPopup.classList.add('visible');
                setTimeout(() => {
                    warningPopup.querySelector('.popup').classList.add('visible');
                }, 10);
                
                // Close popup when clicking outside
                const outsideClick = (e) => {
                    if (e.target === warningPopup) {
                        closeWarningPopup();
                        warningPopup.removeEventListener('click', outsideClick);
                    }
                };
                warningPopup.addEventListener('click', outsideClick);
            }
            
            // Close warning popup
            function closeWarningPopup() {
                warningPopup.querySelector('.popup').classList.remove('visible');
                setTimeout(() => {
                    warningPopup.classList.remove('visible');
                }, 300);
            }
            
            // Add new cube when clicking the add button
            function addNewCube() {
                const cubesInArea = cubeArea.querySelectorAll('.cube');
                
                // Check if we've reached the maximum number of cubes
                if (cubesInArea.length >= 6) {
                    showWarningPopup();
                    // Add shake animation to button for feedback
                    addButton.style.animation = 'shake 0.5s ease-in-out';
                    setTimeout(() => {
                        addButton.style.animation = '';
                    }, 500);
                    return; // Don't add more than 6 cubes
                }
                
                const cubeSize = 60;
                const xPos = (cubeArea.offsetWidth - cubeSize) / 2;
                
                // Calculate y position based on existing cubes
                let yPos = 60;
                if (cubesInArea.length > 0) {
                    const lastCube = cubesInArea[cubesInArea.length - 1];
                    yPos = lastCube.offsetTop + lastCube.offsetHeight + 10;
                }
                
                // Get the selected value from dropdown
                const value = parseInt(cubeValueSelect.value) || 1;
                
                createCube(xPos, yPos, value, cubeArea);
                
                // Update cube count display
                updateCubeCountDisplay();
            }
            
            // Create a new cube element
            function createCube(x, y, value, container) {
                const cube = document.createElement('div');
                cube.className = 'cube';
                cube.innerHTML = `<span class="num">${value}</span>`;
                cube.dataset.value = value;
                
                // Position the cube
                cube.style.left = `${x}px`;
                cube.style.top = `${y}px`;
                
                // Apply styles based on value
                const cubeStyles = getCubeStyle(value);
                Object.assign(cube.style, cubeStyles);
                // Expose size to CSS via custom property for proportional face sizing
                if (cubeStyles.width) {
                    cube.style.setProperty('--size', cubeStyles.width);
                }
                
                // Add event listeners for dragging
                addDragListeners(cube);
                
                container.appendChild(cube);
                cubeCount++;
                updateCubeCount(1);
                
                return cube;
            }
            
            // Get the style for a cube based on its value
            function getCubeStyle(value) {
                const style = {
                    width: (40 + (value * 2)) + 'px',
                    height: (40 + (value * 2)) + 'px',
                    lineHeight: (40 + (value * 2)) + 'px',
                    position: 'absolute',
                    borderRadius: '16px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontWeight: 'bold',
                    fontSize: '20px',
                    cursor: 'move',
                    userSelect: 'none',
                    boxShadow: '0 2px 5px rgba(0,0,0,0.2)'
                };
                
                // Previous bold color definition
                switch(parseInt(value)) {
                    case 1:
                        style.backgroundColor = '#ff4444'; // Red
                        style.color = 'white';
                        break;
                    case 2:
                        style.backgroundColor = '#ff8c00'; // Orange
                        style.color = 'white';
                        break;
                    case 3:
                        style.backgroundColor = '#ffd700'; // Yellow
                        style.color = 'black';
                        break;
                    case 4:
                        style.backgroundColor = '#4CAF50'; // Green
                        style.color = 'white';
                        break;
                    case 5:
                        style.backgroundColor = '#2196F3'; // Blue
                        style.color = 'white';
                        break;
                    case 6:
                        style.backgroundColor = '#9c27b0'; // Purple
                        style.color = 'white';
                        break;
                    case 7:
                        // Rainbow gradient
                        style.background = 'linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)';
                        style.color = 'black';
                        break;
                    case 8:
                        style.backgroundColor = '#e91e63'; // Pink
                        style.color = 'white';
                        break;
                    case 9:
                        style.backgroundColor = '#9e9e9e'; // Grey
                        style.color = 'black';
                        break;
                    case 10:
                        style.backgroundColor = '#ffffff'; // White
                        style.border = '2px solid #ff4444';
                        style.color = '#333';
                        break;
                    default:
                        // For values beyond 10
                        const hue = (value * 36) % 360;
                        style.backgroundColor = `hsl(${hue}, 80%, 60%)`;
                        style.color = value > 5 ? 'white' : 'black';
                }
                
                return style;
            }
            
            // Add drag event listeners to a cube
            function addDragListeners(cube) {
                // Touch events
                cube.addEventListener('touchstart', handleTouchStart, { passive: false });
                cube.addEventListener('touchmove', handleTouchMove, { passive: false });
                cube.addEventListener('touchend', handleTouchEnd);
                
                // Mouse events
                cube.addEventListener('mousedown', handleMouseDown);
                
                // Make draggable for desktop
                cube.draggable = true;
                cube.addEventListener('dragstart', handleDragStart);
            }
            
            // Touch event handlers
            function handleTouchStart(e) {
                if (e.cancelable) e.preventDefault();
                const touch = e.touches[0];
                
                // Add touch feedback
                this.classList.add('touch-feedback');
                setTimeout(() => {
                    this.classList.remove('touch-feedback');
                }, 150);
                
                startDrag(touch.clientX, touch.clientY, this);
            }
            
            function handleTouchMove(e) {
                if (e.cancelable) e.preventDefault();
                if (!activeCube) return;
                
                const touch = e.touches[0];
                moveDrag(touch.clientX, touch.clientY);
            }
            
            function handleTouchEnd() {
                endDrag();
            }
            
            // Mouse event handlers
            function handleMouseDown(e) {
                if (e.button !== 0) return; // Only left mouse button
                startDrag(e.clientX, e.clientY, this);
                
                const moveHandler = (e) => {
                    moveDrag(e.clientX, e.clientY);
                };
                
                const upHandler = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', upHandler);
                    endDrag();
                };
                
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', upHandler);
            }
            
            function handleDragStart(e) {
                // Only needed for desktop drag and drop
                e.preventDefault();
            }
            
            // Drag and drop functions
            function startDrag(clientX, clientY, cube) {
                activeCube = cube;
                activeCube.classList.add('dragging');
                
                const rect = activeCube.getBoundingClientRect();
                offsetX = clientX - rect.left;
                offsetY = clientY - rect.top;
                
                // Move to body for smooth dragging
                if (activeCube.parentElement === cubeArea || activeCube.parentElement === combiningArea) {
                    document.body.appendChild(activeCube);
                }
                
                // Update position
                moveDrag(clientX, clientY);
            }
            
            function moveDrag(clientX, clientY) {
                if (!activeCube) return;
                
                // Calculate new position
                const x = clientX - offsetX - window.scrollX;
                const y = clientY - offsetY - window.scrollY;
                
                // Update cube position
                activeCube.style.left = `${x}px`;
                activeCube.style.top = `${y}px`;
                
                // Highlight drop zones
                const cubeRect = activeCube.getBoundingClientRect();
                const cubeCenterX = cubeRect.left + (cubeRect.width / 2);
                const cubeCenterY = cubeRect.top + (cubeRect.height / 2);
                
                // Check if over combining area
                const combiningRect = combiningArea.getBoundingClientRect();
                const isOverCombining = (
                    cubeCenterX >= combiningRect.left &&
                    cubeCenterX <= combiningRect.right &&
                    cubeCenterY >= combiningRect.top &&
                    cubeCenterY <= combiningRect.bottom
                );
                
                // Visual feedback for drop zones
                if (isOverCombining) {
                    combiningArea.classList.add('drag-over');
                } else {
                    combiningArea.classList.remove('drag-over');
                }
            }
            
            function endDrag() {
                if (!activeCube) return;
                
                const cubeRect = activeCube.getBoundingClientRect();
                const cubeCenterX = cubeRect.left + (cubeRect.width / 2);
                const cubeCenterY = cubeRect.top + (cubeRect.height / 2);
                
                // Check if dropped in combining area
                const combiningRect = combiningArea.getBoundingClientRect();
                const isOverCombining = (
                    cubeCenterX >= combiningRect.left &&
                    cubeCenterX <= combiningRect.right &&
                    cubeCenterY >= combiningRect.top &&
                    cubeCenterY <= combiningRect.bottom
                );
                
                // Check for collisions with other cubes only in the combining area
                let targetCube = null;
                if (isOverCombining) {
                    const allCubes = combiningArea.querySelectorAll('.cube');
                    for (const cube of allCubes) {
                        if (cube === activeCube) continue;
                        
                        const rect = cube.getBoundingClientRect();
                        // Only combine if the center of the dragged cube is over the target cube
                        if (
                            cubeCenterX >= rect.left &&
                            cubeCenterX <= rect.right &&
                            cubeCenterY >= rect.top &&
                            cubeCenterY <= rect.bottom
                        ) {
                            targetCube = cube;
                            break;
                        }
                    }
                }
                
                // Handle the drop
                if (targetCube) {
                    // Combine cubes
                    combineCubes(activeCube, targetCube);
                } else if (isOverCombining) {
                    // Move to combining area at the exact drop position
                    const containerRect = combiningArea.getBoundingClientRect();
                    const x = cubeCenterX - containerRect.left - (activeCube.offsetWidth / 2);
                    const y = cubeCenterY - containerRect.top - (activeCube.offsetHeight / 2);
                    
                    // Ensure position is within bounds
                    const maxX = containerRect.width - activeCube.offsetWidth;
                    const maxY = containerRect.height - activeCube.offsetHeight;
                    
                    activeCube.style.left = `${Math.max(0, Math.min(x, maxX))}px`;
                    activeCube.style.top = `${Math.max(0, Math.min(y, maxY))}px`;
                    
                    // Set the container and update data attribute
                    activeCube.dataset.originalContainer = 'combining';
                    combiningArea.appendChild(activeCube);
                    
                    // Update cube count display
                    updateCubeCountDisplay();
                } else {
                    // Return to original container but keep the position
                    if (activeCube.parentElement === document.body) {
                        const originalContainer = activeCube.dataset.originalContainer === 'combining' ? combiningArea : cubeArea;
                        const containerRect = originalContainer.getBoundingClientRect();
                        
                        // Calculate position relative to the original container
                        const x = cubeCenterX - containerRect.left - (activeCube.offsetWidth / 2);
                        const y = cubeCenterY - containerRect.top - (activeCube.offsetHeight / 2);
                        
                        // Ensure position is within bounds
                        const maxX = containerRect.width - activeCube.offsetWidth;
                        const maxY = containerRect.height - activeCube.offsetHeight;
                        
                        activeCube.style.left = `${Math.max(0, Math.min(x, maxX))}px`;
                        activeCube.style.top = `${Math.max(0, Math.min(y, maxY))}px`;
                        
                        originalContainer.appendChild(activeCube);
                    }
                }
                
                // Clean up
                resetAreaStyles();
                activeCube.classList.remove('dragging');
                activeCube = null;
            }
            
            // Combine two cubes
            function combineCubes(cube1, cube2) {
                const value1 = parseInt(cube1.dataset.value);
                const value2 = parseInt(cube2.dataset.value);
                const newValue = value1 + value2;
                
                // Get position of the cube that was dropped onto (cube2)
                const container = cube2.parentElement;
                const rect = cube2.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                // Calculate position relative to container
                const x = rect.left - containerRect.left;
                const y = rect.top - containerRect.top;
                
                // Remove the original cubes
                cube1.remove();
                cube2.remove();
                
                // Create a new combined cube at the exact position of cube2
                const newCube = createCube(x, y, newValue, container);
                // Add a pop animation to celebrate combining
                newCube.classList.add('pop');
                newCube.addEventListener('animationend', () => {
                    newCube.classList.remove('pop');
                }, { once: true });
                
                // Update highest value if needed
                if (newValue > highestValue) {
                    highestValue = newValue;
                    document.title = `Block Playground 🧱 - ${highestValue}`;
                }
                
                // Update cube count (we removed 2 cubes and added 1)
                updateCubeCount(-1);
                
                // Don't check for additional combinations to prevent unwanted movements
            }
            
            // Check for possible combinations with the dropped cube
            // This function is kept for reference but not used to prevent unwanted combinations
            function checkForCombinations(droppedCube) {
                // Intentionally left empty to prevent automatic combinations
                // Cubes will only combine when explicitly dropped onto each other
            }
            
            // Reset area styles
            function resetAreaStyles() {
                combiningArea.classList.remove('drag-over');
            }
            
            // Update cube appearance based on value
            function updateCubeAppearance(cube) {
                const value = parseInt(cube.dataset.value);
                const styles = getCubeStyle(value);
                Object.assign(cube.style, styles);
                if (styles.width) {
                    cube.style.setProperty('--size', styles.width);
                }
            }
            
            // Update cube counter
            function updateCubeCount(change) {
                cubeCount += change;
                cubeCountElement.textContent = cubeCount;
                
                // Update cube count display
                const cubesInArea = cubeArea.querySelectorAll('.cube').length;
                cubeCountDisplay.textContent = `(${cubesInArea}/6)`;
            }
            
            // Update cube count display
            function updateCubeCountDisplay() {
                const cubesInArea = cubeArea.querySelectorAll('.cube').length;
                cubeCountDisplay.textContent = `(${cubesInArea}/6)`;
            }
            
            // Reset the game
            function resetGame() {
                if (confirm('Start over? This will clear your blocks so you can play again!')) {
                    // Remove all cubes
                    const cubes = document.querySelectorAll('.cube');
                    cubes.forEach(cube => cube.remove());
                    
                    // Reset counters
                    cubeCount = 0;
                    highestValue = 0;
                    cubeCountElement.textContent = '0';
                    document.title = 'Block Playground 🧱';
                    
                    // Reset cube count display
                    cubeCountDisplay.textContent = '(0/6)';
                    
                    // Add initial cube
                    addNewCube();
                }
            }
            
            // Prevent default touch behavior
            document.addEventListener('touchmove', (e) => {
                if (activeCube && e.cancelable) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Initialize the game
            init();
        });
    </script>
</body>
</html>
